Vue组件：vue-virtual-scroller
React组件：react-window
**实现原理：**
只渲染视口大小的列表，减少创建DOM数量
两种场景：1，高度固定，2，高度不固定
基本结构：
```js
<div style={{ height: totalHeight, overflowY: 'auto' }} ref={outerRef}>
	<div style={{ height: visibleHeight, position: 'relative' }}>
		{visibleItems.map(item => (
			<div
				key={index}
				style={{
					position: 'absolute',
					top: index * itemHeight,
					height: itemHeight,
					width: '100%'
				}}
			>		
				{renderItem(...)}
			</div>
		))}
	</div>
</div>
```
**外层容器高度 = 所有数据的总高度**（撑开滚动条）
**内部只渲染可视项**
**每个 item**：用 `position: absolute` 定位到正确位置，只渲染可见项。

通过监听滚动事件获取 `scrollTop`：
如果每一项高度固定：
```js
const startIndex = Math.floor(scrollTop / itemHeight);
const visibleCount = Math.ceil(viewHeight / itemHeight) + buffer; // buffer 预留上下几个item
const endIndex = Math.min(startIndex + visibleCount, itemCount - 1);
```
只渲染 `[startIndex, endIndex]` 范围内的项。
如果每一项高度不固定：
- 初始时用一个默认高度（如 50px）快速布局。
- 用户滚动到某项时，**测量真实高度**并缓存。
- 高度缓存：内部维护一个数组或 Map，记录每项的真实高度
```js
const itemSizeCache = [40, 60, 55, 70, ...];
```
前缀和数组：为了快速计算第 N 项的 `top` 值，维护一个累计高度数组
```js
const offsetCache = [0, 40, 100, 155, 225, ...]; // offsetCache[i] = 前 i 项总高度 → 第 i 项的 `top = offsetCache[i]`
```
因为高度不规则，不能直接用 `scrollTop / avgHeight`。
- 使用二分查找在 `offsetCache` 中找到最大的 `i` 满足 `offsetCache[i] <= scrollTop`
- 即为当前可视区域的起始索引。