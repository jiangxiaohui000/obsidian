`stale-while-revalidate`：是一种HTTP层缓存策略，在允许的时间范围内，先给用户展示“旧的（stale）”缓存数据，同时在后台静默地“校验/更新（revalidate）”数据，以便下次使用最新的内容。
**让用户永远感觉“秒开”，同时保证内容在后台自动更新。**
```js
// max-age=60: 在 60 秒内，缓存是新鲜的（Fresh），直接从缓存读取。
// 60-90秒内，立即返回旧缓存给用户（秒开），同时在后台偷偷发一个请求去服务器取新数据。
// 90秒后，缓存失效，重新请求
Cache-Control: max-age=60, stale-while-revalidate=30
```
#### 极速的加载性能 (Zero Latency)
由于浏览器在宽限期内直接返回缓存，用户不需要等待网络请求往返（RTT）。这对于改善 **LCP** 指标非常有帮助，用户感知的速度是“瞬间”的。
#### 容错能力 (Resilience)
如果后台更新请求失败（例如服务器临时宕机），用户至少还能看到旧的内容，而不是一个报错页面或加载圈，这极大提升了系统的可用性。
#### 缓解服务器并发压力
当大量用户几乎同时访问某个过期资源时，SWR 确保只有一个后台请求发往服务器进行更新，而其他用户依然在读取旧缓存，避免了“缓存击穿”带来的瞬时高并发压力。

如何启用？
Nginx 配置示例
```nginx
location / {
  add_header Cache-Control "public, max-age=60, stale-while-revalidate=30";
}
```

项目中，看点页面，内容页面适合这种缓存策略。