## 一、性能优化的整体框架

前端性能优化可以拆解为四个层次：

1. **资源加载层**：资源是否更快、更早、更少地被加载
    
2. **渲染执行层**：是否减少主线程阻塞、重排与重绘
    
3. **架构层**：是否通过 SSR / 预渲染 / Worker 等手段绕开瓶颈
    
4. **指标导向层**：围绕 LCP / CLS / INP 做针对性优化
    

核心原则只有一句话：

> **让关键内容尽早加载、尽快渲染、避免中途被打断。**

---

## 二、资源加载优化（决定 LCP 上限）

### 1. 网络与传输层优化

- 使用 **CDN** 缩短资源物理距离
- 启用 **Gzip / Brotli** 压缩
- 合理利用缓存体系：
    - 浏览器缓存（强缓存 / 协商缓存）
    - CDN 缓存
    - Service Worker 缓存
---
### 2. 提前建立连接

减少 DNS、TCP、TLS 握手耗时：
- `preconnect`：建立完整连接（DNS + TCP + TLS）
- `dns-prefetch`：仅提前解析 DNS，作为兼容兜底

适用于：字体、CDN、第三方脚本等**高优先级外部资源**。

---

### 3. 关键资源预加载（Preload）

- 使用 `rel="preload"` 提示浏览器**提高关键资源优先级**
- 适用于：
    - 首屏图片（Hero Image）
    - Web 字体
    - 关键 CSS / JS
配合 `imagesrcset + imagesizes`，可在响应式场景下避免资源浪费。

---

### 4. 图片优化（LCP 的核心）

LCP 元素通常是：
- `<img>`
- `<video>`
- CSS `background-image`
优化策略：
- 使用 **响应式图片（picture / srcset）**
- 提供 **WebP / AVIF** 等新格式
- 图片压缩（构建期 + CDN）
- 使用 **图片 CDN**
- 非首屏图片懒加载（IntersectionObserver）
- 图标优先使用 SVG / 字体图标
- 谨慎使用 Base64（仅适合极小资源）

---

## 三、浏览器渲染与执行优化

### 1. 减少重排与重绘

- 动画只使用 `transform` / `opacity`
    
- 避免频繁读写布局属性（如 `offsetHeight`）
    
- 批量 DOM 操作
    

### 2. 动画优化

- 优先使用 **CSS 动画**
    
- JS 动画使用 `requestAnimationFrame`
    
- 对动画元素使用 `will-change`（谨慎）
    

### 3. CSS 阻塞优化

- 削减 CSS 体积（Tree Shaking / 压缩）
    
- 内联首屏关键 CSS
    
- 非关键 CSS 延迟加载（`preload + onload`）
    
- 使用工具自动化（如 Critters）
    

---

### 4. JavaScript 阻塞优化

- 代码拆分（SplitChunks / 动态 import）
    
- 避免无差别 polyfill
    
- 使用 `type="module"` + 精准浏览器目标
    
- 合理使用 `async / defer`
    

---

## 四、架构级优化手段

### 1. Web Worker

- 将**复杂计算**移出主线程
    
- 典型场景：
    
    - 大数据处理
        
    - JSON 解析
        
    - 图像处理
        

### 2. 服务端渲染 / 预渲染

- SSR：提升首屏 HTML 可用性
    
- 预渲染：适用于内容相对静态页面
    

核心价值：

> **让浏览器更早拿到可渲染内容，而不是等 JS 执行完成。**

---

## 五、围绕 Core Web Vitals 的专项优化

### 1. LCP（最大内容绘制）

核心目标：**让 LCP 资源更早加载、更快渲染**

关键手段：

1. 提高关键资源优先级（`preload` / `fetchpriority="high"`）
    
2. LCP 资源与 HTML 同源，复用连接
    
3. 减少 CSS / JS 阻塞
    
4. 缩小资源体积（图片 / 字体）
    
5. CDN + 缓存
    

总结为四句话：

- 尽早加载
    
- 立即渲染
    
- 尽量变小
    
- 尽快拿到 HTML
    

---

### 2. CLS（布局偏移）

核心问题：**页面加载过程中元素位置发生变化**

解决方案：

- 图片明确 `width / height` 或 `aspect-ratio`
    
- 为动态内容预留空间
    
- 避免在视口顶部插入延迟加载内容
    
- 使用 `transform` 动画
    
- 字体使用 `preload`，避免 FOIT/FOUT
    

---

### 3. INP（交互到下一次绘制）

INP 本质：**主线程是否被长任务占用**

优化策略：

- 拆分长任务（>50ms）
    
- 使用 `setTimeout(0)` / `requestAnimationFrame` 让出主线程
    
- 使用 Web Worker
    
- 延迟非关键脚本执行
    
- 利用 `navigator.scheduling.isInputPending()`（实验性）
    

核心思想：

> **用户交互永远优先于非关键逻辑。**

---

## 六、评估与监控

### 1. 线上评估

- PageSpeed Insights（真实用户数据）
    
- Search Console（站点级问题定位）
    

### 2. 本地与实验室工具

- Lighthouse
    
- Web Vitals 扩展
    
- Chrome Performance 面板
    

---

## 七、一句话总结（面试高频版）

> 前端性能优化本质是围绕 Core Web Vitals，通过减少关键资源加载时间、降低主线程阻塞、避免布局抖动，让首屏更快可见、交互更快响应。

![1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8112d143f0254837960706a3d295f5b9~tplv-k3u1fbpfcp-watermark.image?)