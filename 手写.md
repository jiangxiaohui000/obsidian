## 迭代器模式

```js
function $each(data, handle) {
  if (typeof data !== "object" || data === null) throw TypeError("data should be object!");

  if (!data[Symbol.iterator]) {
    data[Symbol.iterator] = function () {
      let i = 0;
      let keys = Reflect.ownKeys(data);
      return {
        next() {
          const done = i >= keys.length;
          return {
            value: done ? undefined : data[keys[i++]],
            done,
          };
        },
      };
    };
  }
  for (const item of data) {
    handle(item);
  }
}
```
## 发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.handlers = {};
  }

  on(name, handle) {
    if (!this.handlers[name]) {
      this.handlers[name] = [];
    }
    this.handlers[name].push(handle);
  }

  off(name, handle) {
    if (this.handlers[name]) {
      if (handle) {
        this.handlers[name] = this.handlers[name].filter(h => h !== handle);
      } else {
        this.handlers[name] = [];
      }
    }
  }

  emit(name, ...args) {
    if (this.handlers[name]) {
      this.handlers[name].forEach((handle) => {
        handle(...args);
      });
    }
  }

  once(name, handle) {
    const onceHandle = (...args) => {
      handle(...args);
      this.off(name, onceHandle);
    };
    this.on(name, onceHandle);
  }
}
```
## 观察者模式

```js
// 被观察者
class Subject {
    constructor() {
        this.observerList = []; // 观察者列表
    }
    addObserver(observer) {
        this.observerList.push(observer);
    }
    removeObserver(observer) {
        const index = this.observerList.findIndex(item => item.name === observer.name);
        this.observerList.splice(index, 1);
    }
    notifyObserver(message) {
        this.observerList.forEach(item => item.notify(message));
    }
}
// 观察者
class Observer {
    constructor(name) {
        this.name = name;
    }
    notify(message) {
        console.log(message);
    }
}
const subject = new Subject();
const observerA = new Observer('observerA');
const observerB = new Observer('observerB');
subject.addObserver(observerA);
subject.addObserver(observerB);
subject.notifyObserver('from subject1');
subject.removeObserver(observerA);
subject.notifyObserver('hello again');
```
## 洗牌算法

```js
function shuffle(arr) {
    const len = this.nums.length;
    // 从前往后
    for(let i = 0; i < len; i++) {
        let j = Math.floor(Math.random() * (len - i)) + i;
        [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]];
    }
    // 从后往前
    for(let i = len - 1; i > 0; i--){
        let j = Math.floor(Math.random() * (i + 1));
        [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]];
    }
    return this.nums;
}
```
## 手写new
- new干了什么事？
    - 创建一个新的对象
    - 继承父类原型上的方法.
    - 添加父类的属性到新的对象上并初始化. 保存方法的执行结果.
    - 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象。
- 实现：

```js
// 方式1
function _new(target, ...args) {
    // 基于target的原型创建一个新的对象
    let obj = Object.create(target.prototype);
    // 添加属性到新创建的obj上, 并获取obj函数执行的结果
    let res = target.apply(obj, args);
    // 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象
    return typeof res === 'object' ? res : obj;
}
// 方式2
function _new(target, ...args) {
    let obj = {};
    obj._proto_ = target.prototype;
    let res = target.apply(obj, args);
    return typeof res === 'object' ? res : obj;
}
```
## 手写call、apply

```js
Function.prototype.myCall/myApply = function(context, ...args) {
  // 健壮性检查，调用者必须为函数
  if (typeof this !== 'function') return;
  // 检查传入的context是否合法
  context = context === undefined || context === null ? globalThis : Object(context);
  // 将当前函数this临时挂载到传入的对象上
  const key = Symbol(); // 定义一个symbol的key，是为了不污染this上的属性
  context[key] = this;
  // 通过函数调用，改变this指向
  const res = context[key](...args); // call
  const res = context[key](args); // apply
  // 清除副作用
  delete context[key];
  return res;
}
```
## 手写bind

```js
Function.prototype.myBind = function(context, ...args) {
  const fn = this;
  function newFn(...newFnArgs) {
    const allArg = [...args, ...newFnArgs];
    // bind的绑定优先级 < new 绑定优先级
    // bind返回的函数，如果是当做构造函数被new调用，那么this要指向新对象
    if(this instanceof newFn) { // this是否是newFn的实例
      return fn.apply(this, allArg); // new调用就绑定到this上
    }
    // 普通调用
    return fn.apply(context, allArg); // 否则就绑定到传入的context上
  }
  // 复制原型（不修改 fn.prototype）
  newFn.prototype = Object.create(fn.prototype);
  return newFn;
}
```
## 深拷贝

```js
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (map.has(obj)) return map.get(obj); // 处理循环引用，避免无限递归
  let cloneObj = Array.isArray(obj) ? [] : {};
  map.set(obj, cloneObj);
  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], map);
    }
  }
  return cloneObj;
}
```
## 防抖

```js
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = null;
    }, delay);
  }
}
```
## 节流

```js
function throttle(fn, delay) {
	let timer = null;
	let lastTime = 0;
	return function(...args) {
		let now = Date.now();
		let remaining = delay - (now - lastTime);
		if (remaining <= 0) { // 直接执行
			timer && clearTimeout(timer);
			lastTime = now;
			fn.apply(this, args);
		} else if (!timer) { // 如果当前在队列中已经有了定时器，就不用再创建了，继续创建会持续往队列增加回调，失去了节流的作用
			timer = setTimeout(() => {
				lastTime = Date.now();
				timer = null;
				fn.apply(this, args);
			}, remaining);
		}
	}
}
```
## 手写instance

```js
function myInstance(target, fn) {
	if (typeof target !== 'object' || target === null) return false;
	if (typeof fn !== 'function') throw new TypeError('');
	let _proto = Object.getPrototypeOf(target);
	while(_proto) {
		if (_proto === fn.prototype) return true;
		_proto = Object.getPrototypeOf(_proto);
	}
	return false;
}
```
## 手写reduce

```js
Array.prototype.myReduce = function(fn, initial) {
	const arr = this;
	let result;
	let startIndex = 0;
	if (arguments.length >= 2) { // 代表传了初始值
		result = initial;
	} else { // 未传初始值
		if (!arr.length) throw new Error('Reduce of empty array with no initial value');
		result = arr[0];
		startIndex = 1;
	}
	for (let i = startIndex; i < arr.length; i++) {
		if (i in arr) { // arr有可能是稀疏数组，通过i in arr判断某个索引是否“存在于数组中”，用来跳过空洞。
			result = fn(result, arr[i], i, arr);
		}
	}
	return result;
}
```
## promise并发请求

```js
const request = url => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(`任务${url}完成`)
    }, 1000)
  }).then(res => {
    console.log('外部逻辑', res);
  })
}

let urls = [
    'bytedance.com',
    'tencent.com',
    'alibaba.com',
    'microsoft.com',
    'apple.com',
    'hulu.com',
    'amazon.com'
] // 请求地址

let pool = []; // 请求池
let limit = 3; // 同时请求个数限制

while(pool.length < limit) {
  const url = urls.shift();
  url && addTask(url);
}

function addTask(url) {
  const task = request(url).finally(() => {
	  pool = pool.filter(item => item !== task);
	  const url = urls.shift();
	  url && addTask(url);
  });
  pool.push(task);
}
```

```js
// 现有8个图片资源的url，已经存储在数组urls中，
// 且已有一个函数function loading，输入一个url链接，返回一个Promise，
// 该Promise在图片下载完成的时候resolve，下载失败则reject。
// 要求：任何时刻同时下载的链接数量不可以超过3个。
// 请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。
var urls = [
  'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg',
  'https://www.kkkk1000.com/images/getImgData/gray.gif',
  'https://www.kkkk1000.com/images/getImgData/Particle.gif',
  'https://www.kkkk1000.com/images/getImgData/arithmetic.png',
  'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif',
  'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg',
  'https://www.kkkk1000.com/images/getImgData/arithmetic.gif',
  'https://www.kkkk1000.com/images/wxQrCode2.png'
];
function loadImg(url) {
    return new Promise((resolve, reject) => {
        const img = new Image()
        img.onload = () => {
            console.log('一张图片加载完成');
            resolve();
        }
        img.onerror = reject;
        img.src = url;
    })
};
```

```js
function limitLoad(urls, handler, limit) {
  // 对数组做一个拷贝
  const sequence = [...urls];
  let promises = [];
  //并发请求到最大数
  promises = sequence.splice(0, limit).map((url, index) => {
    // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标
    return handler(url).then(() => {
      return index;
    });
  });

  // 利用数组的 reduce 方法来以队列的形式执行
  return sequence.reduce((last, url, currentIndex) => {
    return last.then(() => {
      // 返回最快改变状态的 Promise
      return Promise.race(promises)
    }).catch(err => {
      // 这里的 catch 不仅用来捕获前面 then 方法抛出的错误
      // 更重要的是防止中断整个链式调用
      console.error(err)
    }).then((res) => {
      // 用新的 Promise 替换掉最快改变状态的 Promise
      promises[res] = handler(sequence[currentIndex]).then(() => {
        return res
      });
    })
  }, Promise.resolve()).then(() => {
    return Promise.all(promises)
  })

}

limitLoad(urls, loadImg, 3);

因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用

limitLoad(urls, loadImg, 3).then(() => {
    console.log('所有图片加载完成');
}).catch(err => {
    console.error(err);
})
```

```js
const timeout1 = ms => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
}

const ajax1 = () => timeout1(2000).then(() => {
  console.log('1');
  return 1;
});

const ajax2 = () => timeout1(1000).then(() => {
  console.log('2');
  return 2;
});

const ajax3 = () => timeout1(2000).then(() => {
  console.log('3');
  return 3;
});

// 实现一：
const mergePromise = ajaxArray => {
  const data = [];
  let sequece = Promise.resolve();
  ajaxArray.forEach(item => {
    sequece = sequece.then(item).then(res => {
      data.push(res);
      return data;
    })
  })
  return sequece;
};
// 实现二：
async function mergePromise(ajaxArray) {
    let task = [];
    for (let i = 0; i < ajaxArray.length; i++) {
       let res = await Promise.resolve().then(ajaxArray[i]);
       task.push(res);
    }
    return Promise.all(task);
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log('done');
  console.log(data); // data 为 [1, 2, 3]
});
```

```js
// 异步函数fn1
const fn1 = function () {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('111')
        }, 500)
    })
}
// 异步函数fn2
const fn2 = (data) => {
    return new Promise((resolve, reject) => {
        resolve(data + '222')
    })
}
// 异步函数fn3
const fn3 = (data) => {
    return new Promise((resolve, reject) => {
        setTimeout(function () {
            resolve(data + '333')
        }, 1000)
    })
}
// 实现：
async function queue(arr) {
    let res = null
    for (let promise of arr) {
        res = await promise(res)
    }
    return res;
}
// 因为async返回返回的也是promise，所以可以使用then
queue([fn1, fn2, fn3]).then(data => {
    console.log(data) // 111222333
})
```
**原型链
```js
class A {}
class B extends A
const a = new A()
const b = new B()
console.log(a.__proto__ === A.prototype) // true
console.log(b.__proto__ === B.prototype) // true
console.log(B.__proto__ === A) // true
console.log(B.prototype.__proto__ === A.prototype) // true
console.log(B.__proto__.prototype === A.prototype) // true
console.log(b.__proto__.__proto__ === A.prototype) // true
```

```js
// 普通函数的this指向受到调用方的影响，谁调用，this指向谁
// 箭头函数的this在函数定义时就确定了，不受调用方的影响
// 箭头函数会捕获所在上下文的this，继承外层作用域的this
// 使用call、apply、bind改变this指向时，箭头函数不受影响
var a = 1;
function test() {
  // 通过bind将test函数绑定到一个新的上下文{ a: 2 }上，然后调用
  setTimeout(() => {
    console.log(this.a); // 2
  }, 0);
  // 定时器，在调用时在全局，this指向window
  setTimeout(function() {
    console.log(this.a) // 1
  }, 0);
  // 普通函数，收到bind影响，this指向{a: 2}
  console.log(this.a) // 2
}
test.bind({a: 2})();
```
```js
// 箭头函数的 this 由其定义位置的词法作用域决定，而不是由调用方式或其所在对象决定。
// 如果箭头函数定义在对象字面量中，由于对象不是作用域，因此箭头函数会继续向上查找外层作用域，最终可能找到全局作用域（浏览器中是 window）。
const obj = {
    a: 1,
    fn: () => {
        console.log(this)
        return this.a
    },
    fn1: function () {
        console.log(this);
        return this.a;
    }
}
// 用let、const声明的变量不会挂载到window上，因为块级作用域。var会
const a = 2;
const fn = obj.fn;
const fn1 = obj.fn1;
// 箭头函数
// 因为箭头函数在声明时，绑定了外层函数所在的上下文this
// 此时是window，且无法被改变
// 所以this都指向window
console.log(obj.fn()) // this指向window，this.a是undefined
console.log(fn()) // this指向window，this.a是undefined
console.log(obj.fn.call(null)) // this指向window，this.a是undefined
// 普通函数
console.log(obj.fn1()) // this指向obj，this.a是1
console.log(fn1()) // fn1是普通函数，被赋值给了一个变量，执行时是在全局下，所以this指向window，this.a是undefined
console.log(obj.fn1.call(null)) // 普通函数被call、apply改变了this指向，且为null，就指向了window，this.a是undefined
```
```js
// 与上题相对应，此时obj是一个类，也就是函数
class Obj {
    constructor() {
        this.a = 1;
    }
    fn = () => {
        console.log(this)
        return this.a
    }
    fn2 = function () {
        console.log(this);
        return this.a;
    }
}
const obj = new Obj();
const a = 2;
const fn = obj.fn;
const fn2 = obj.fn2;
// 箭头函数
// this都是指向obj，因为箭头函数定义时绑定了外层函数的this，也就是Obj
console.log(obj.fn()) // 1
console.log(fn()) // 1
console.log(obj.fn.call(null)) // 1 
// 普通函数
// 在严格模式下，将内部普通函数赋值一个变量再执行，this是不会挂在window上的
console.log(obj.fn2()) // 1
console.log(fn2()) // 会报错，因为是严格模式，this指向undefined，Cannot read properties of undefined (reading 'a')
console.log(obj.fn2.call(null)) // 会报错，因为this指向null，Cannot read properties of null (reading 'a')
```

```js
// 在严格模式下，将内部普通函数赋值一个变量再执行，是不会挂在window上的
class A { // 默认严格模式
    constructor() {
        this.name = 'cat'
    }
    speak() {
        console.log(this)
        console.log(this.name)
    }
    eat = () => {
        console.log(this)
        console.log(this.name)
    }
}
const n = new A();
n.speak(); // this指向A，this.name是cat
n.eat(); // this指向A，this.name是cat
const _speak = n.speak;
const _eat = n.eat;
_speak(); // 会报错，this指向undefined，找不到a
_eat(); // this指向A
```
即便把箭头函数赋值给一个新变量，在全局下执行，也不会改变箭头函数的this指向，它在定义的时候就确定了this的指向。箭头函数的this指向，在定义的时候就确定了，是它的外层是函数的情况下。

---
```js
// 这里一个知识点：函数声明的提升和函数表达式的提升
// 函数声明：function XXX() {}；函数表达式：var XXX = function () {}
// 在编译阶段，JS引擎会扫描代码，将函数声明提升到作用域的顶部。可以在函数声明之前调用函数。
// 函数表达式在编译阶段只会提升变量的声明，而不会提升整个函数。
// ！！！注意：函数声明的提升优先级高于变量声明的提升。如果同时存在函数声明和变量声明，函数声明会覆盖变量声明。
// 因为let、const有暂时性死区，声明同名的变量会报错
function Foo() {
  getName = function () {
      console.log(1);
  };
  console.log(this)
  return this;
}
Foo.getName = function () {
    console.log (2);
};
Foo.prototype.getName = function () {
    console.log (3);
};
var getName = function () {
    console.log (4);
};
function getName() {
    console.log (5);
}

Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1 Foo()在全局下执行，返回了this，然后就变成了this.getName()，它内部的getName没有用let、const声明，也是全局的，this指向window；如果用let、const声明了，那么该句执行就是4
getName(); // 1 上一步中，Foo()执行后，里面的getName变成了全局函数，所以再执行getName()，打印的就是1了
new Foo.getName(); // 2
new Foo().getName(); // 3 new Foo()生成了一个实例，返回的this指向这个实例，由于原型链的原因，该实例能够访问到原型上的getName()
new new Foo().getName(); // 3
```
---
JS判断循环引用

```js
function cycle(obj, parent) {
    //表示调用的父级数组
    var parentArr = parent || [obj];
    for (var i in obj) {
        if (typeof obj[i] === "object") {
            //判断是否有循环引用
            parentArr.forEach((pObj) => {
                if (pObj === obj[i]) {
                    obj[i] = "[cycle]"
                }
            });
            cycle(obj[i], [...parentArr, obj[i]])
        }
    }
    return obj;
}
```
---

```js
Object.is = function (x, y) {
    if (x === y) {
        // JS中+0 === -0，所以x===y的情况下，要么x,y不能是0，要么是0的看情况下，1/x === 1/y
        // 1/+0 = +Infinity， 1/-0 = -Infinity, +Infinity不等于-Infinity
        // Infinity 属性用于存放表示正无穷大的数值。负无穷大是表示负无穷大一个数字值。
        return x !== 0 || 1 / x === 1 / y;
    }
    // 一个变量不等于自身变量,那么它一定是 NaN
    // 两个都是NaN的时候返回true
    return x !== x && y !== y;
};
```
---
```js
// 冒泡排序
// 每一轮遍历，把当前未排序部分中的最大（或最小）元素，冒泡到该部分的末尾。
 function bubbleSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
	    let swapped = false; // 记录本轮循环是否有交换
	    for (let j = 0; j < arr.length - i - 1) {
		    if (arr[j] > arr[j + 1]) {
			    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
			    swapped = true;
		    }
	    }
	    if (!swapped) break; // 没有交换说明已经排序完成，提前结束
    }
    reutrn arr;
  }
```
---

```js
// 快速排序
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    let temp = arr[0];
    let leftArr = [];
    let rightArr = [];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < temp) {
            leftArr.push(arr[i]);
        } else {
            rightArr.push(arr[i]);
        }
    }
    return quickSort(leftArr).concat(temp, quickSort(rightArr));
  }
```