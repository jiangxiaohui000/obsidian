## 迭代器模式

```js
function $each(data, handle) {
  if (typeof data !== "object" || data === null) throw TypeError("data should be object!");

  if (!data[Symbol.iterator]) {
    data[Symbol.iterator] = function () {
      let i = 0;
      let keys = Reflect.ownKeys(data);
      return {
        next() {
          const done = i >= keys.length;
          return {
            value: done ? undefined : data[keys[i++]],
            done,
          };
        },
      };
    };
  }
  for (const item of data) {
    handle(item);
  }
}
```
## 发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.handlers = {};
  }

  on(name, handle) {
    if (!this.handlers[name]) {
      this.handlers[name] = [];
    }
    this.handlers[name].push(handle);
  }

  off(name, handle) {
    if (this.handlers[name]) {
      if (handle) {
        this.handlers[name] = this.handlers[name].filter(h => h !== handle);
      } else {
        this.handlers[name] = [];
      }
    }
  }

  emit(name, ...args) {
    if (this.handlers[name]) {
      this.handlers[name].forEach((handle) => {
        handle(...args);
      });
    }
  }

  once(name, handle) {
    const onceHandle = (...args) => {
      handle(...args);
      this.off(name, onceHandle);
    };
    this.on(name, onceHandle);
  }
}
```
## 观察者模式

```js
// 被观察者
class Subject {
    constructor() {
        this.observerList = []; // 观察者列表
    }
    addObserver(observer) {
        this.observerList.push(observer);
    }
    removeObserver(observer) {
        const index = this.observerList.findIndex(item => item.name === observer.name);
        this.observerList.splice(index, 1);
    }
    notifyObserver(message) {
        this.observerList.forEach(item => item.notify(message));
    }
}
// 观察者
class Observer {
    constructor(name) {
        this.name = name;
    }
    notify(message) {
        console.log(message);
    }
}
const subject = new Subject();
const observerA = new Observer('observerA');
const observerB = new Observer('observerB');
subject.addObserver(observerA);
subject.addObserver(observerB);
subject.notifyObserver('from subject1');
subject.removeObserver(observerA);
subject.notifyObserver('hello again');
```
## 洗牌算法

```js
function shuffle(arr) {
    const len = this.nums.length;
    // 从前往后
    for(let i = 0; i < len; i++) {
        let j = Math.floor(Math.random() * (len - i)) + i;
        [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]];
    }
    // 从后往前
    for(let i = len - 1; i > 0; i--){
        let j = Math.floor(Math.random() * (i + 1));
        [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]];
    }
    return this.nums;
}
```
## 手写new
- new干了什么事？
    - 创建一个新的对象
    - 继承父类原型上的方法.
    - 添加父类的属性到新的对象上并初始化. 保存方法的执行结果.
    - 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象。
- 实现：

```js
// 方式1
function _new(target, ...args) {
    // 基于target的原型创建一个新的对象
    let obj = Object.create(target.prototype);
    // 添加属性到新创建的obj上, 并获取obj函数执行的结果
    let res = target.apply(obj, args);
    // 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象
    return typeof res === 'object' ? res : obj;
}
// 方式2
function _new(target, ...args) {
    let obj = {};
    obj._proto_ = target.prototype;
    let res = target.apply(obj, args);
    return typeof res === 'object' ? res : obj;
}
```
## 手写call、apply

```js
Function.prototype.myCall/myApply = function(context, ...args) {
  // 健壮性检查，调用者必须为函数
  if (typeof this !== 'function') return;
  // 检查传入的context是否合法
  context = context === undefined || context === null ? globalThis : Object(context);
  // 将当前函数this临时挂载到传入的对象上
  const key = Symbol(); // 定义一个symbol的key，是为了不污染this上的属性
  context[key] = this;
  // 通过函数调用，改变this指向
  const res = context[key](...args); // call
  const res = context[key](args); // apply
  // 清除副作用
  delete context[key];
  return res;
}
```
## 手写bind

```js
Function.prototype.myBind = function(context, ...args) {
  const fn = this;
  function newFn(...newFnArgs) {
    const allArg = [...args, ...newFnArgs];
    // bind的绑定优先级 < new 绑定优先级
    // bind返回的函数，如果是当做构造函数被new调用，那么this要指向新对象
    if(this instanceof newFn) { // this是否是newFn的实例
      return fn.apply(this, allArg); // new调用就绑定到this上
    }
    // 普通调用
    return fn.apply(context, allArg); // 否则就绑定到传入的context上
  }
  // 复制原型（不修改 fn.prototype）
  newFn.prototype = Object.create(fn.prototype);
  return newFn;
}
```
## 深拷贝

```js
function deepClone(obj, map = new WeakMap()) {
  if(obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if(map.has(obj)) return map.get(obj);
  let cloneObj = Array.isArray(obj) ? [] : {};
  map.set(obj, cloneObj);
  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], map);
    }
  }
  return cloneObj;
}
```
## 防抖

```js
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.call(this, ...args);
      timer = null;
    }, delay);
  }
}
```
## 节流

```js
function throttle(fn, delay) {
  let timer = null;
  let startTime = Date.now();
  return function(...args) {
    let endTime = Date.now();
    if(endTime - startTime < delay) {
      // 如果距离上次执行的时间小于设定的延迟时间，则清除上一次的定时器
      timer && clearTimeout(timer);
      // 设定一个新的定时器，确保在 delay 时间后执行一次
      timer = setTimeout(() => {
        startTime = Date.now(); 
        fn.apply(this, args); 
      }, delay)
    } else {
      // 如果距离上次执行的时间已经超过了 delay，直接执行函数
      startTime = Date.now();
      fn.apply(this, args);
    }
  }
}
```
## 手写instance

```js
function myInstance(target, fn) {
  while(target && target.__proto__) {
    if(target.__proto__ === fn.prototype) {
      return true;
    }
    target = target.__proto__;
  }
  return false;
}
```
## 手写reduce

```js
Array.prototype.myReduce = function(fn, initial) {
  let arr = this;
  if(initial === undefined) {
    initial = arr.shift();
  }
  let res = initial;
  arr.forEach(item => {
    res = fn(res, item);
  });
  return res;
}
```
## promise并发请求

```js
var request = url => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(`任务${url}完成`)
    }, 1000)
  }).then(res => {
    console.log('外部逻辑', res);
  })
}

let urls = [
    'bytedance.com',
    'tencent.com',
    'alibaba.com',
    'microsoft.com',
    'apple.com',
    'hulu.com',
    'amazon.com'
] // 请求地址

let pool = []; // 请求池
let limit = 3; // 同时请求个数限制
while(pool.length < limit) {
  let url = urls.shift();
  url && addTask(url);
}

function addTask(url) {
  let task = request(url);
  pool.push(task);
  task.then(() => {
    pool.splice(pool.indexOf(task), 1);
    let url = urls.shift();
    url && addTask(url);
  });
}
```

```js
// 现有8个图片资源的url，已经存储在数组urls中，
// 且已有一个函数function loading，输入一个url链接，返回一个Promise，
// 该Promise在图片下载完成的时候resolve，下载失败则reject。
// 要求：任何时刻同时下载的链接数量不可以超过3个。
// 请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。
var urls = [
  'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg',
  'https://www.kkkk1000.com/images/getImgData/gray.gif',
  'https://www.kkkk1000.com/images/getImgData/Particle.gif',
  'https://www.kkkk1000.com/images/getImgData/arithmetic.png',
  'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif',
  'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg',
  'https://www.kkkk1000.com/images/getImgData/arithmetic.gif',
  'https://www.kkkk1000.com/images/wxQrCode2.png'
];
function loadImg(url) {
    return new Promise((resolve, reject) => {
        const img = new Image()
        img.onload = () => {
            console.log('一张图片加载完成');
            resolve();
        }
        img.onerror = reject;
        img.src = url;
    })
};
```

```js
function limitLoad(urls, handler, limit) {
  // 对数组做一个拷贝
  const sequence = [...urls];
  let promises = [];
  //并发请求到最大数
  promises = sequence.splice(0, limit).map((url, index) => {
    // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标
    return handler(url).then(() => {
      return index;
    });
  });

  // 利用数组的 reduce 方法来以队列的形式执行
  return sequence.reduce((last, url, currentIndex) => {
    return last.then(() => {
      // 返回最快改变状态的 Promise
      return Promise.race(promises)
    }).catch(err => {
      // 这里的 catch 不仅用来捕获前面 then 方法抛出的错误
      // 更重要的是防止中断整个链式调用
      console.error(err)
    }).then((res) => {
      // 用新的 Promise 替换掉最快改变状态的 Promise
      promises[res] = handler(sequence[currentIndex]).then(() => {
        return res
      });
    })
  }, Promise.resolve()).then(() => {
    return Promise.all(promises)
  })

}

limitLoad(urls, loadImg, 3);

因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用

limitLoad(urls, loadImg, 3).then(() => {
    console.log('所有图片加载完成');
}).catch(err => {
    console.error(err);
})
```

```js
const timeout1 = ms => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
}

const ajax1 = () => timeout1(2000).then(() => {
  console.log('1');
  return 1;
});

const ajax2 = () => timeout1(1000).then(() => {
  console.log('2');
  return 2;
});

const ajax3 = () => timeout1(2000).then(() => {
  console.log('3');
  return 3;
});

// 实现一：
const mergePromise = ajaxArray => {
  const data = [];
  let sequece = Promise.resolve();
  ajaxArray.forEach(item => {
    sequece = sequece.then(item).then(res => {
      data.push(res);
      return data;
    })
  })
  return sequece;
};
// 实现二：
async function mergePromise(ajaxArray) {
    let task = [];
    for (let i = 0; i < ajaxArray.length; i++) {
       let res = await Promise.resolve().then(ajaxArray[i]);
       task.push(res);
    }
    return Promise.all(task);
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log('done');
  console.log(data); // data 为 [1, 2, 3]
});
```

```js
// 异步函数fn1
const fn1 = function () {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('111')
        }, 500)
    })
}
// 异步函数fn2
const fn2 = (data) => {
    return new Promise((resolve, reject) => {
        resolve(data + '222')
    })
}
// 异步函数fn3
const fn3 = (data) => {
    return new Promise((resolve, reject) => {
        setTimeout(function () {
            resolve(data + '333')
        }, 1000)
    })
}
// 实现：
async function queue(arr) {
    let res = null
    for (let promise of arr) {
        res = await promise(res)
    }
    return res;
}
// 因为async返回返回的也是promise，所以可以使用then
queue([fn1, fn2, fn3]).then(data => {
    console.log(data) // 111222333
})
```