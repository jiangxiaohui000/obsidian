```js
class A {}
class B extends A
const a = new A()
const b = new B()
console.log(a.__proto__ === A.prototype) // true
console.log(b.__proto__ === B.prototype) // true
console.log(B.__proto__ === A) // true
console.log(B.prototype.__proto__ === A.prototype) // true
console.log(B.__proto__.prototype === A.prototype) // true
console.log(b.__proto__.__proto__ === A.prototype) // true
```

```js
// 普通函数的this指向受到调用方的影响，谁调用，this指向谁
// 箭头函数的this在函数定义时就确定了，不受调用方的影响
// 箭头函数会捕获所在上下文的this，继承外层作用域的this
// 使用call、apply、bind改变this指向时，箭头函数不受影响
var a = 1;
function test() {
  // 通过bind将test函数绑定到一个新的上下文{ a: 2 }上，然后调用
  setTimeout(() => {
    console.log(this.a); // 2
  }, 0);
  // 定时器，在调用时在全局，this指向window
  setTimeout(function() {
    console.log(this.a) // 1
  }, 0);
  // 普通函数，收到bind影响，this指向{a: 2}
  console.log(this.a) // 2
}
test.bind({a: 2})();
```
```js
// 箭头函数的 this 由其定义位置的词法作用域决定，而不是由调用方式或其所在对象决定。
// 如果箭头函数定义在对象字面量中，由于对象不是作用域，因此箭头函数会继续向上查找外层作用域，最终可能找到全局作用域（浏览器中是 window）。
const obj = {
    a: 1,
    fn: () => {
        console.log(this)
        return this.a
    },
    fn1: function () {
        console.log(this);
        return this.a;
    }
}
// 用let、const声明的变量不会挂载到window上，因为块级作用域。var会
const a = 2;
const fn = obj.fn;
const fn1 = obj.fn1;
// 箭头函数
// 因为箭头函数在声明时，绑定了外层函数所在的上下文this
// 此时是window，且无法被改变
// 所以this都指向window
console.log(obj.fn()) // this指向window，this.a是undefined
console.log(fn()) // this指向window，this.a是undefined
console.log(obj.fn.call(null)) // this指向window，this.a是undefined
// 普通函数
console.log(obj.fn1()) // this指向obj，this.a是1
console.log(fn1()) // fn1是普通函数，被赋值给了一个变量，执行时是在全局下，所以this指向window，this.a是undefined
console.log(obj.fn1.call(null)) // 普通函数被call、apply改变了this指向，且为null，就指向了window，this.a是undefined
```
```js
// 与上题相对应，此时obj是一个类，也就是函数
class Obj {
    constructor() {
        this.a = 1;
    }
    fn = () => {
        console.log(this)
        return this.a
    }
    fn2 = function () {
        console.log(this);
        return this.a;
    }
}
const obj = new Obj();
const a = 2;
const fn = obj.fn;
const fn2 = obj.fn2;
// 箭头函数
// this都是指向obj，因为箭头函数定义时绑定了外层函数的this，也就是Obj
console.log(obj.fn()) // 1
console.log(fn()) // 1
console.log(obj.fn.call(null)) // 1 
// 普通函数
// 在严格模式下，将内部普通函数赋值一个变量再执行，this是不会挂在window上的
console.log(obj.fn2()) // 1
console.log(fn2()) // 会报错，因为是严格模式，this指向undefined，Cannot read properties of undefined (reading 'a')
console.log(obj.fn2.call(null)) // 会报错，因为this指向null，Cannot read properties of null (reading 'a')
```

```js
// 在严格模式下，将内部普通函数赋值一个变量再执行，是不会挂在window上的
class A { // 默认严格模式
    constructor() {
        this.name = 'cat'
    }
    speak() {
        console.log(this)
        console.log(this.name)
    }
    eat = () => {
        console.log(this)
        console.log(this.name)
    }
}
const n = new A();
n.speak(); // this指向A，this.name是cat
n.eat(); // this指向A，this.name是cat
const _speak = n.speak;
const _eat = n.eat;
_speak(); // 会报错，this指向undefined，找不到a
_eat(); // this指向A
```


即便把箭头函数赋值给一个新变量，在全局下执行，也不会改变箭头函数的this指向，它在定义的时候就确定了this的指向。箭头函数的this指向，在定义的时候就确定了，是它的外层是函数的情况下。

---
```js
// 这里一个知识点：函数声明的提升和函数表达式的提升
// 函数声明：function XXX() {}；函数表达式：var XXX = function () {}
// 在编译阶段，JS引擎会扫描代码，将函数声明提升到作用域的顶部。可以在函数声明之前调用函数。
// 函数表达式在编译阶段只会提升变量的声明，而不会提升整个函数。
// ！！！注意：函数声明的提升优先级高于变量声明的提升。如果同时存在函数声明和变量声明，函数声明会覆盖变量声明。
// 因为let、const有暂时性死区，声明同名的变量会报错
function Foo() {
  getName = function () {
      console.log(1);
  };
  console.log(this)
  return this;
}
Foo.getName = function () {
    console.log (2);
};
Foo.prototype.getName = function () {
    console.log (3);
};
var getName = function () {
    console.log (4);
};
function getName() {
    console.log (5);
}

Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1 Foo()在全局下执行，返回了this，然后就变成了this.getName()，它内部的getName没有用let、const声明，也是全局的，this指向window；如果用let、const声明了，那么该句执行就是4
getName(); // 1 上一步中，Foo()执行后，里面的getName变成了全局函数，所以再执行getName()，打印的就是1了
new Foo.getName(); // 2
new Foo().getName(); // 3 new Foo()生成了一个实例，返回的this指向这个实例，由于原型链的原因，该实例能够访问到原型上的getName()
new new Foo().getName(); // 3
```
---
JS判断循环引用

```js
function cycle(obj, parent) {
    //表示调用的父级数组
    var parentArr = parent || [obj];
    for (var i in obj) {
        if (typeof obj[i] === "object") {
            //判断是否有循环引用
            parentArr.forEach((pObj) => {
                if (pObj === obj[i]) {
                    obj[i] = "[cycle]"
                }
            });
            cycle(obj[i], [...parentArr, obj[i]])
        }
    }
    return obj;
}
```
---

```js
Object.is = function (x, y) {
    if (x === y) {
        // JS中+0 === -0，所以x===y的情况下，要么x,y不能是0，要么是0的看情况下，1/x === 1/y
        // 1/+0 = +Infinity， 1/-0 = -Infinity, +Infinity不等于-Infinity
        // Infinity 属性用于存放表示正无穷大的数值。负无穷大是表示负无穷大一个数字值。
        return x !== 0 || 1 / x === 1 / y;
    }
    // 一个变量不等于自身变量,那么它一定是 NaN
    // 两个都是NaN的时候返回true
    return x !== x && y !== y;
};
```
---
```js
// 冒泡排序
 function bubbleSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        for (let j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    reutrn arr;
  }
```
---

```js
// 快速排序
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    let temp = arr[0];
    let leftArr = [];
    let rightArr = [];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < temp) {
            leftArr.push(arr[i]);
        } else {
            rightArr.push(arr[i]);
        }
    }
    return quickSort(leftArr).concat(temp, quickSort(rightArr));
  }
```