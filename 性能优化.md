![1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8112d143f0254837960706a3d295f5b9~tplv-k3u1fbpfcp-watermark.image?)
### 资源加载优化：
1. CDN
2. Gzip压缩
3. 缓存
- 浏览器缓存
- 代理缓存
- CDN缓存
- Service Worker
4. 尽早建立第三方连接
```js
使用`rel="preconnect"`来告知浏览器您的页面打算尽快建立连接。
<link rel="preconnect" href="https://example.com" />
```
```js
使用`dns-prefetch`来更快地完成 DNS 查找。
<link rel="dns-prefetch" href="https://example.com" />
```
```js
对于不支持`preconnect`的浏览器，可以考虑将`dns-prefetch`做为后备。
<head>  
…  
<link rel="preconnect" href="https://example.com" />  
<link rel="dns-prefetch" href="https://example.com" />  
</head>
```
5. 预加载重要资源
使用`<link rel="preload">`来更加及时地获取该资源。
从 Chrome 73 开始，预加载可以与[响应式图像](https://web.dev/preload-responsive-images/)一起使用，将两种模式相结合能够实现更快速的图像加载。
```js
<link  
    rel="preload"  
    as="image"  
    href="wolf.jpg"  
    imagesrcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w, wolf_1600px.jpg 1600w"  
    imagesizes="50vw"  
/>
```
使用 picture 标签来定义零或多个 source 节点和一个 img 节点，用于提供图片在不同设备/显示场景下对应的内容展示。

```js
// 针对不同大小的屏幕，提供不同的图片
<picture>
  <source srcset="hzfe-avatar-desktop.png" media="(min-width: 990px)" />
  <source srcset="hzfe-avatar-tablet.png" media="(min-width: 750px)" />
  <img src="hzfe-avatar.png" alt="hzfe-default-avatar" />
</picture>
```

```js
// 优先提供webp格式的图片，如果不支持，会降级处理
<picture>
  <source srcset="hzfe-avatar.webp" type="image/webp" />
  <source srcset="hzfe-avatar.jpg" type="image/jpeg" />
  <img src="hzfe-avatar.jpg" alt="hzfe-default-avatar" />
</picture>
```
```js
// 按需加载适合用户设备的图片
<picture>
  <source
    srcset="hzfe-avatar-desktop.png, hzfe-avatar-desktop-2x.png 2x"
    media="(min-width: 990px)"
  />
  <source
    srcset="hzfe-avatar-tablet.png, hzfe-avatar-tablet-2x.png 2x"
    media="(min-width: 750px)"
  />
  <img
    srcset="hzfe-avatar.png, hzfe-avatar-2x.png 2x"
    src="hzfe-avatar.png"
    alt="hzfe-default-avatar"
  />
</picture>
```
6. 影响 LCP 的元素类型为：
    -   `<img>`元素
    -   `<video>`元素
    -   通过`url()`函数（而非使用CSS 渐变）加载的带有背景图像的元素
 
    **有几种方法可以确保尽快加载这些文件**：
    -   优化和压缩图像（例如使用 [Imagemin](https://web.dev/use-imagemin-to-compress-images)）
    -   预加载重要资源
    -   基于网络连接交付不同资产（自适应服务）
    -   使用 Service Worker 缓存资产
    -   将图像转换为更新的格式（JPEG 2000、JPEG XR 或 WebP）
    -   使用响应式图像
    -   考虑使用图像 CDN
    -   图片懒加载：先将图片URL存放在自定义属性data-xxx中，使用 Intersection Observer，监听dom元素与父元素的交集，等到图片元素出现在屏幕中时，再把值赋值给src属性。
    -   使用字体图标
    -   图片转base64，减少HTTP请求
7. 使用 Web Worker多线程，Web Worker专门处理复杂计算的，从此让前端拥有后端的计算能力
8. 服务端渲染、预渲染
9. 使用requestAnimationFrame处理动画，优势：属于GUI引擎，不占用JS引擎；刷新率固定，使用定时器的话，会受到事件循环机制的影响，导致时间不准；页面隐藏时，RAF会暂停，而定时器会在后台持续执行。

**浏览器渲染优化**：
- 减少浏览器的重排和重绘的发生。
- 动画中只使用transform和opacity：transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响，不会造成重排和重绘。
- 尽可能地只使用css做动画，不用js做动画，避免占据主线程。
- 给动画元素添加 will-change CSS属性。
- 减少 CSS 阻塞时间
    - 削减 CSS，对于 webpack：[optimize-css-assets-webpack-plugin]
    - 延迟加载非关键 CSS，这里运用了`rel="preload"`和`onload`。

    ```js
    <link rel="preload" href="stylesheet.css" as="style" onload="this.rel='stylesheet'">
    ```
    - 内联关键 CSS，通过把用于首屏内容的任何关键路径 CSS 直接包括在`<head>`中来将这些 CSS 进行内联。如果您无法为您的网站手动添加内联样式，请使用库来将该过程自动化。-   [Critters](https://github.com/GoogleChromeLabs/critters) 是一个 webpack 插件，能够内联关键 CSS 并对其余部分进行懒加载。
- 减少 JavaScript 阻塞时间
    - 代码拆分 SplitChunksPlugin
    - 最大限度减少未使用的 polyfill

    ```js
    Use `@babel/preset-env` with appropriate browser targets.
    Use `<script type="module">` to stop sending transpiled code to browsers that don't need it.
    ```

**优化LCP**：
1. 消除资源加载延迟
- 为资源提高加载优先级：您可以通过 [`fetchpriority`](https://web.dev/articles/fetch-priority?hl=zh-cn) 属性提示浏览器哪些资源最重要，以表明资源若能从较高的优先级中获益：
````
<img fetchpriority="high" src="/path/to/hero-image.webp">
````
- 最好将关键资源与 HTML 文档资源托管在同一源上，因为这些资源可以通过重复使用现有连接来节省时间
2. 消除元素渲染延迟
    1. 减少css的加载渲染阻塞：
        - 如果css文件很小，则可以内嵌到HTML中，减少网络请求造成的阻塞。
        - 如果css文件很大，则不适合内嵌，此时需要缩减css文件大小：
            - 移除未使用的css
            - 延迟加载非关键css：将首页用到的或者关键的css内嵌到HTML中，其他css使用网络请求
    2. 减少JS的加载渲染阻塞：
        - 如果JS文件很小，可以选择内嵌到HTML中
        - 其他大型JS文件，在script标签中使用async或者defer延迟加载JS
        - 拆分长任务，避免主线程长时间被占用
3. 缩短资源加载时间
    - 缩减资源大小：图片和字体
        - 提供大小合适的图片
        - 提供新格式图片，如webP
        - 图片压缩
        - 缩减字体文件
    - 缩短资源需要的行程距离
        - 使用CDN
    - 消除网络时间
        - 缓存资源

概括来讲，优化 LCP 可以总结为四个步骤：

1.  确保 LCP 资源尽早开始加载。
2.  确保 LCP 元素可在其资源完成加载后立即渲染。
3.  在不牺牲质量的情况下，尽可能缩短 LCP 资源的加载时间。
4.  尽快提供初始 HTML 文档。

**优化CLS** 主要是对图片和字体的优化

1. 给图片设置宽高
2. aspect-ratio
3. 给动态插入的元素预留空间，如设置最小高度
4. 避免将延迟加载的内容放置在视口顶部附近
5. 使用transform动画，不会引起重新布局
6. 使用 `<link rel=preload>` 尽早加载关键网页字体

**优化FID**
FID产生的主要原因是主线程被占用，即JS计算解析太密集，无法响应用户输入
- 拆分长任务，代码拆分：重点关注执行时长超过50ms的task
- 使用Web Worker
- 关键路径或首屏内容不需要的脚本，推迟使用：代码拆分；使用defer或者async
1. `async` 属性：

-   **执行时机：** 脚本的下载和执行是异步的，当浏览器遇到 `<script async>` 时，它会立即开始下载脚本，并在下载的过程中继续解析文档。一旦脚本下载完成，它将会立即执行，而不会等待页面的其他内容加载。
-   **执行顺序：** 多个异步脚本的执行顺序是不确定的，取决于哪个先下载完成。
-   **适用场景：** 适用于独立的脚本，不依赖于页面的其他内容。
2. `defer` 属性：

-   **执行时机：** 脚本的下载是异步的，但执行是延迟的。当浏览器遇到 `<script defer>` 时，它会立即开始下载脚本，但会等到文档解析完毕后、`DOMContentLoaded` 事件触发前执行脚本。如果有多个延迟脚本，它们会按照它们在文档中出现的顺序依次执行。
-   **执行顺序：** 脚本的执行顺序是按照它们在文档中出现的顺序依次执行的。
-   **适用场景：** 适用于需要等待整个文档解析完毕后再执行的脚本，通常放在文档底部。
### 总结：

-   使用 `async` 时，脚本的下载和执行是异步的，不会阻塞文档的解析，但执行顺序不确定。
-   使用 `defer` 时，脚本的下载是异步的，但执行会延迟到文档解析完毕后，按照它们在文档中出现的顺序依次执行。

一般来说，如果你的脚本不依赖于文档的其他内容，并且你希望脚本尽早执行，可以使用 `async`。如果你希望脚本在整个文档解析完毕后执行，可以使用 `defer`。


**优化INP**
```
// 让出主线程
function yieldToMain () {
  return new Promise(resolve => {
    setTimeout(resolve, 0);
  });
}
````

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac6b62dfa29d461d8651a2953e32cc6c~tplv-k3u1fbpfcp-watermark.image?)

曾经的单体式任务现在被分解成了单独的任务。
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9df8183a1704f608ba9527d5ce0d2ad~tplv-k3u1fbpfcp-watermark.image?)

```
// 当用户尝试与页面互动时，该方法返回true，否则返回false
// 可以利用这个方法，如果返回true，则让出主线程
// 兼容性不好
navigator.scheduling.isInputPending()
````

在`requestAnimationFrame()` 调用中使用 `setTimeout()`，可确保非关键代码不会阻止下一帧。比如用户输入时，把保存操作，检查操作，请求接口操作等，放在requestAnimationFrame的setTimeout中。


**一、评估网站**
- 使用 [PageSpeed Insights](https://pagespeed.web.dev/?hl=zh-cn) 查看关于源网址的总体核心网页指标体验指标，以及单个网址的具体信息
- 使用[Search Console](https://search.google.com/search-console/about?hl=zh-cn) 找出需要改进的网页

**二、优化网站**
- Lighthouse
- Web Vitals 扩展程序
- Performance性能面板